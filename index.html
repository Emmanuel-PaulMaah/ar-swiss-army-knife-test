<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mobile Web AR Capability + Console</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --ok:#0b7a0b; --bad:#b00020; --warn:#a15c00; --muted:#666; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 16px; line-height: 1.5; }
    h1 { font-size: 1.25rem; margin-bottom: 0.5rem; }
    ul { padding-left: 1.1rem; }
    li { margin: 0.25rem 0; }
    .status { font-weight: 600; }
    .supported { color: var(--ok); }
    .unsupported { color: var(--bad); }
    .warn { color: var(--warn); }
    .muted { color: var(--muted); }
    .row { display: flex; gap: 8px; flex-wrap: wrap; margin: 8px 0 12px; }
    button { padding: 0.55em 0.9em; border: 1px solid #ccc; background: #f7f7f7; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    #host { width: 100%; height: 52vh; background: #000; display: none; position: relative; }
    #msg { margin-top: 8px; white-space: pre-wrap; color: var(--bad); }
    details { margin-top: 12px; border: 1px solid #ddd; border-radius: 6px; }
    summary { padding: 8px 10px; font-weight: 600; cursor: pointer; }
    #console { padding: 8px 10px; max-height: 30vh; overflow: auto; background: #0f0f0f; color: #eaeaea; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    .log .lvl { color:#9cdcfe } .warn .lvl{ color:#ffcc00 } .error .lvl{ color:#ff6b6b }
    .log time { color:#888; margin-right:6px }
    .kv { color:#b3b3b3 }
    a { color: #0366d6; }
    .hint { font-size: 0.9em; color: var(--muted); }
    .chip { display:inline-block; padding:2px 6px; border:1px solid #ccc; border-radius:999px; font-size:12px; margin-left:6px; }
  </style>
</head>
<body>
  <h1>Mobile Web AR Capability Test</h1>
  <div class="hint">Use over HTTPS or localhost. iOS requires user gestures for camera and motion.</div>

  <ul id="results"></ul>

  <div class="row">
    <button id="runBtn">Run Diagnostics</button>
    <button id="probeAllBtn">Run Full Probe (prompts)</button>
    <button id="motionBtn" style="display:none">Grant Motion</button>
    <button id="startBtn" disabled>Start AR</button>
  </div>

  <div id="host"></div>
  <div id="msg"></div>

  <details>
    <summary>Console output</summary>
    <div id="console"></div>
  </details>

<script>
/* ---------- lightweight console to <div> ---------- */
(function hookConsole(){
  const pane = document.getElementById('console');
  const maxLines = 800;
  const stamp = () => new Date().toISOString().split('T')[1].replace('Z','');
  const escape = s => (s+'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
  const toStr = (v) => {
    try {
      if (typeof v === 'string') return v;
      if (v instanceof Error) return v.stack || (v.name+': '+v.message);
      if (typeof v === 'object') return JSON.stringify(v, (_k,val)=> typeof val==='bigint'? String(val): val, 2);
      return String(v);
    } catch { return String(v); }
  };
  function write(level, args){
    const el = document.createElement('div');
    el.className = level;
    const text = Array.from(args).map(toStr).join(' ');
    el.innerHTML = `<span class="lvl">[${escape(level.toUpperCase())}]</span> <time>${escape(stamp())}</time> ${escape(text)}`;
    pane.appendChild(el);
    while (pane.childNodes.length > maxLines) pane.removeChild(pane.firstChild);
    pane.scrollTop = pane.scrollHeight;
  }
  ['log','info','warn','error'].forEach(fn=>{
    const orig = console[fn].bind(console);
    console[fn] = (...a)=>{ write(fn==='info'?'log':fn, a); orig(...a); };
  });
  window.addEventListener('error', e => write('error', [e.message, e.filename+':'+e.lineno+':'+e.colno, e.error && e.error.stack]));
  window.addEventListener('unhandledrejection', e => write('error', ['Unhandled promise rejection', e.reason]));
})();

/* ---------- DOM refs ---------- */
const results = document.getElementById('results');
const runBtn = document.getElementById('runBtn');
const probeAllBtn = document.getElementById('probeAllBtn');
const motionBtn = document.getElementById('motionBtn');
const startBtn = document.getElementById('startBtn');
const host = document.getElementById('host');
const msg = document.getElementById('msg');

/* ---------- helpers ---------- */
const ua = navigator.userAgent;
const isIOS = /iP(hone|ad|od)/i.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
const isAndroid = /Android/i.test(ua);

function add(label, ok, info='') {
  const li = document.createElement('li');
  li.innerHTML = `${label}: <span class="status ${ok ? 'supported' : 'unsupported'}">${ok ? '✅ Supported' : '❌ Not Supported'}</span> ${info}`;
  results.appendChild(li);
}

function chip(text, cls='chip'){ return `<span class="${cls}">${text}</span>`; }

async function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

/* ---------- probes ---------- */
let arSupported = false;
let motionGranted = false;

async function diagBasic(){
  results.innerHTML = '';
  add('Secure context (HTTPS)', window.isSecureContext);
  add('Platform', true, isAndroid ? 'Android' : isIOS ? 'iOS' : 'Other');
  add('User agent', true, chip(navigator.userAgent));
  add('Device memory hint', 'deviceMemory' in navigator, 'deviceMemory' in navigator ? chip(navigator.deviceMemory+' GB') : chip('n/a'));
  add('Hardware concurrency', 'hardwareConcurrency' in navigator, chip(navigator.hardwareConcurrency || 'n/a'));
  add('Navigator.xr present', !!navigator.xr);

  // WebGL / WebGL2
  try {
    const c = document.createElement('canvas');
    const gl1 = c.getContext('webgl') || c.getContext('experimental-webgl');
    const gl2 = c.getContext('webgl2');
    add('WebGL', !!gl1, gl1 ? chip('OK') : '');
    add('WebGL2', !!gl2, gl2 ? chip('OK') : chip('fallback to WebGL'));
  } catch { add('WebGL', false); add('WebGL2', false); }

  // Permissions API presence
  add('Permissions API', !!navigator.permissions);

  // MediaDevices
  add('MediaDevices API', !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia));

  // Motion sensor event availability
  const devMotionAvailable = 'DeviceMotionEvent' in window;
  const devOrientAvailable = 'DeviceOrientationEvent' in window;
  add('DeviceMotionEvent API', devMotionAvailable);
  add('DeviceOrientationEvent API', devOrientAvailable);

  // WebXR AR support check
  arSupported = false;
  if (navigator.xr && navigator.xr.isSessionSupported) {
    try {
      arSupported = await navigator.xr.isSessionSupported('immersive-ar');
      add('WebXR immersive-ar', arSupported);
    } catch (e) {
      add('WebXR immersive-ar', false, chip(e.name||'error')+' '+chip((e.message||'').slice(0,80)));
      console.warn('isSessionSupported error', e);
    }
  } else {
    add('WebXR immersive-ar', false, 'navigator.xr missing');
  }

  // Feature names we will attempt to request during a user-gesture probe
  add('AR feature candidates', true, ['local-floor','hit-test','dom-overlay','anchors','hand-tracking','depth-sensing'].map(chip).join(' '));

  // iOS specific notes
  if (isIOS) {
    const needsMotionGesture = (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function');
    if (needsMotionGesture) {
      motionBtn.style.display = 'inline-block';
      add('iOS motion permission model', true, 'Requires user gesture');
    } else {
      add('iOS motion permission model', devMotionAvailable, devMotionAvailable ? 'Legacy or auto-granted' : '');
    }
  } else {
    motionBtn.style.display = 'none';
  }

  // Permissions API quick peek (non-prompting)
  if (navigator.permissions && navigator.permissions.query) {
    const tryQuery = async (name) => {
      try {
        const s = await navigator.permissions.query({ name });
        add(`Permission: ${name}`, true, chip(s.state));
      } catch { add(`Permission: ${name}`, false, chip('unsupported')); }
    };
    // Camera is "camera" in some Chromium builds, "microphone" exists widely. Status often "prompt".
    await tryQuery('camera');
    await tryQuery('microphone');
    await tryQuery('accelerometer');
    await tryQuery('magnetometer');
    await tryQuery('gyroscope');
  }
}

async function probeMotionGesture(){
  if (!(isIOS && typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function')) return;
  try {
    const st = await DeviceMotionEvent.requestPermission();
    motionGranted = (st === 'granted');
    add('Motion permission', motionGranted, chip(st));
    console.log('Motion permission result:', st);
  } catch (e) {
    motionGranted = false;
    add('Motion permission', false, chip(e.name||'error'));
    console.error('Motion permission error', e);
  }
}

async function probeCameraPrompt(){
  if (!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)) {
    add('Camera probe', false, 'getUserMedia unavailable');
    return false;
  }
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
    stream.getTracks().forEach(t => t.stop());
    add('Camera probe', true, 'granted');
    console.log('Camera access OK');
    return true;
  } catch (e) {
    add('Camera probe', false, chip(e.name||'error')+' '+chip((e.message||'').slice(0,80)));
    console.warn('Camera probe failed', e);
    return false;
  }
}

async function passiveMotionCheck(){
  let seen = false;
  const handler = ()=>{ seen = true; window.removeEventListener('devicemotion', handler); };
  window.addEventListener('devicemotion', handler, { once:true });
  await sleep(800);
  add('Device motion events observed', seen, seen ? '' : 'No events within 800ms');
  return seen;
}

async function featureProbeWithSession(){
  // Requires user gesture. We try to start and immediately end a session while asking optional features.
  if (!arSupported) { add('Feature probe', false, 'immersive-ar not supported'); return {}; }
  if (!navigator.xr || !navigator.xr.requestSession) { add('Feature probe', false, 'requestSession unavailable'); return {}; }

  const wanted = ['local-floor','hit-test','dom-overlay','anchors','hand-tracking','depth-sensing'];
  const result = {};
  try {
    const init = {
      requiredFeatures: ['local-floor'],
      optionalFeatures: wanted.filter(f => f !== 'local-floor'),
      domOverlay: { root: document.body },
      depthSensing: { usagePreference: ['cpu-optimized','gpu-optimized'], dataFormatPreference: ['luminance-alpha','float32'] }
    };
    const session = await navigator.xr.requestSession('immersive-ar', init);
    // If we got here, at least the set is accepted.
    wanted.forEach(f => result[f] = 'accepted');
    add('Feature probe', true, 'session created');
    await session.end();
  } catch (e) {
    add('Feature probe', false, chip(e.name||'error')+' '+chip((e.message||'').slice(0,80)));
    console.warn('Feature probe error', e);
  }
  return result;
}

/* ---------- AR session demo ---------- */
async function startAR(){
  msg.textContent = '';
  // iOS: request camera + motion during gesture for best chance
  if (isIOS) {
    await probeMotionGesture();
    const cam = await probeCameraPrompt();
    if (!cam) { msg.textContent = 'Camera permission denied or blocked.'; return; }
  }

  try {
    const init = {
      requiredFeatures: ['local-floor'],
      optionalFeatures: ['dom-overlay','hit-test','anchors','hand-tracking','depth-sensing'],
      domOverlay: { root: document.body },
      depthSensing: { usagePreference: ['cpu-optimized','gpu-optimized'], dataFormatPreference: ['luminance-alpha','float32'] }
    };
    const session = await navigator.xr.requestSession('immersive-ar', init);

    host.innerHTML = '';
    host.style.display = 'block';
    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    host.appendChild(canvas);

    const gl = canvas.getContext('webgl', { alpha:true, antialias:true, xrCompatible:true });
    if (!gl) throw new Error('WebGL context not available');
    if (gl.makeXRCompatible) await gl.makeXRCompatible();

    session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });
    const refSpace = await session.requestReferenceSpace('local-floor');

    function resize(){
      const layer = session.renderState.baseLayer;
      if (!layer) return;
      const w = layer.framebufferWidth, h = layer.framebufferHeight;
      canvas.width = w; canvas.height = h; gl.viewport(0,0,w,h);
    }
    resize(); window.addEventListener('resize', resize);

    session.addEventListener('end', ()=>{ window.removeEventListener('resize', resize); host.style.display='none'; host.innerHTML=''; });

    const onFrame = (t, frame) => {
      session.requestAnimationFrame(onFrame);
      const pose = frame.getViewerPose(refSpace);
      gl.bindFramebuffer(gl.FRAMEBUFFER, session.renderState.baseLayer.framebuffer);
      if (pose) {
        gl.clearColor(0.2,0.6,0.25,0.5);
      } else {
        gl.clearColor(0,0,0,1);
      }
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    };
    session.requestAnimationFrame(onFrame);

  } catch (e) {
    console.error('Failed to start AR', e);
    msg.textContent = 'Failed to start AR: ' + (e.message || e.name || e);
  }
}

/* ---------- wire up ---------- */
runBtn.addEventListener('click', diagBasic);

probeAllBtn.addEventListener('click', async ()=>{
  await diagBasic();
  // Passive motion observation before explicit permission
  await passiveMotionCheck();
  // Prompted probes
  if (isIOS) { await probeMotionGesture(); }
  await probeCameraPrompt();
  // Try creating a session quickly to see which options are accepted
  const feat = await featureProbeWithSession();
  console.log('Feature acceptance map:', feat);
  // Gate Start AR
  startBtn.disabled = !arSupported;
  if (!arSupported) msg.textContent = 'AR not fully supported by this browser/device. Start AR disabled.';
});

motionBtn.addEventListener('click', probeMotionGesture);
startBtn.addEventListener('click', startAR);

// Auto-run light diagnostics at load to populate static info
diagBasic().then(()=>{ startBtn.disabled = !arSupported; });

</script>
</body>
</html>
